

![image](https://github.com/user-attachments/assets/5bbc84f5-5fed-47de-a08c-9f5ac7db3164)

# Bash-Linux-Troubleshoot-and-Automation-Toolkit

## Overview
Effective Linux system administration and cybersecurity necessitate prompt diagnostics, comprehensive visibility, and intelligent automation. This repository consists of a collection of Bash scripts designed to empower Linux administrators, DevOps engineers, and security teams with immediate troubleshooting capabilities. These scripts are intended to capture system metrics, diagnose issues, automate health checks, and enhance operational awareness, all while employing standard Linux utilities without the need for external dependencies.

This toolkit is particularly suitable for system administrators managing Linux servers, professionals engaged in learning Linux system administration, and experienced IT professionals seeking lightweight and reliable utilities for live incident response or root cause analysis. Each script is modular, well-documented, parameterizable, and is safe for utilization across various Linux distributions on servers, workstations, or virtual machines.

---

## Guide

### 📚 Quick‑Start-Guide

Quick Start

To get started with the toolkit, simply clone the repository to your local machine using git. This allows you to immediately access all of the included scripts. Once downloaded, navigate into the directory and make the scripts executable using chmod. You can then run any script directly from your terminal by calling its filename with ./.

These scripts are designed to be portable and require no external libraries, making them ideal for environments with limited internet access or tight security controls. They are suitable for laptops, servers, and virtual machines. Most scripts include comments and examples to help new users understand their purpose and structure.


## Script-Catalogue

## Collect-System-Info
### 1️⃣collect_system_logs.sh

In the investigation of incidents, comprehending the sequence of events is essential. This script automatically collects pertinent system logs (e.g., Syslog, auth.log, kern.log, or journalctl output) within a specified time frame. Rather than manually navigating through various log files or executing complex journalctl queries, this script produces organized output, streamlining the process and reducing the potential for human error. This automation is invaluable during high-pressure situations, ensuring critical log data is captured swiftly and consistently.

The organized output generated by this script significantly facilitates analysis by coherently presenting log entries, often chronologically sorted or pre-filtered based on the specified timeframe. This makes tracing event progressions easier, correlating activities across different log sources, and efficiently using tools like `grep` for specific keyword searches. It's beneficial for post-incident forensic analysis, debugging elusive application failures, tracking unauthorized access attempts, or simply understanding system behavior leading up to a reported issue, saving administrators considerable time and effort.

Operational Details:

**How it works**

> •	Accepts **`HoursBack`**, **`Logs`** (array of log names), and **`OutputDir`**.
> •	Creates the destination folder if it doesn’t exist.
> •	Uses **`Get‑WinEvent`** with a hashtable filter for efficiency (no slow `Where‑Object`).
> •	Selects the most actionable fields (timestamp, event ID, severity, message).
> •	Exports each log type to its own CSV for clean segregation.

**Usage Example**
./collect_system_logs.sh --hours 24 --logs "syslog,auth" --outputdir /var/tmp/incident_logs
# For journalctl specific query
./collect_system_logs.sh --journal_unit sshd --since "2 days ago" --outputdir /var/tmp/ssh_logs


```bash
Insert example here
```

### Code

```bash
Insert code here
```

---

## Monitor-Resources
### 2️⃣ check_system_integrity.sh

The integrity of system files and unexpected modifications can severely undermine system stability and security. This script integrates various native Linux tools, such as rpm -Va for RPM-based distributions or debsums for Debian-based systems, to meticulously verify the integrity of installed packages against their original manifests. It can also be configured to check checksums of critical configuration files, providing an added layer of assurance against unauthorized alterations.

Beyond package verification, this script can optionally facilitate filesystem integrity checks, which are crucial for detecting and potentially correcting inconsistencies or corruption at the filesystem level. While direct `fsck` operations require careful handling (often on unmounted filesystems), the script can guide or report on the status of filesystem health, flagging potential issues that might indicate failing storage hardware or critical software errors. Regularly running such integrity checks helps detect compromised files early, accidental corruption, or malicious tampering, allowing for timely remediation.

How it works (Conceptual)
> •	Builds a log directory to preserve historical runs.
> •	For RPM-based systems (e.g., CentOS, RHEL, Fedora): Executes rpm -Va to verify all installed packages.
> •	For Debian-based systems (e.g., Ubuntu, Debian): Executes debsums (if installed) or dpkg --verify (though dpkg --verify has limitations).
> •	Captures output in a timestamped log file.
> •	Optionally, it could provide information or reminders about running fsck on unmounted filesystems during maintenance windows.

**Usage Example**

```bash
Insert example here
```

### Code

```bash
Insert code here
```

---

## Network-Diagnostics
### 3️⃣ Get‑ActiveConnections

3️⃣ get_active_connections.sh

The presence of malware or unauthorized processes often leads to the establishment of unexpected network connections. This script displays all established TCP and listening UDP connections, crucially identifying each with the corresponding process name, Process ID (PID), and the user who initiated it. This detailed information is paramount for security audits and network troubleshooting, providing a clear view of all network activity originating from or terminating the system.

For security professionals, this script is an essential tool for rapidly identifying suspicious outbound connections that could indicate data exfiltration or communication with command-and-control servers. It also helps pinpoint unauthorized listening services that might have been started by malware or misconfigured applications. For system administrators, it aids in diagnosing network-related application issues, identifying which processes are consuming network resources, or verifying that services are correctly bound to expected network interfaces and ports, ensuring that the system's network posture is secure and functional.

**How it works**

> •	Queries `Get‑NetTCPConnection` for **`State = Established`**.
> •	Resolves Process ID to friendly names using `Get‑Process`.
> •	Retrieves the owning username via CIM’s `Win32_Process.GetOwner()`.
> •	Outputs an alphabetised table ready for copy‑paste into a report or pasted into Grid View.

**Usage Example**

```bash
Insert example here
```


### Code

```bash
Insert code here
```

## System-Snapshot
## 4️⃣ get_system_health_snapshot.sh

Before diving deep into troubleshooting, it is imperative to establish a quick baseline of the system's current operational state. This script efficiently captures a real-time snapshot of key performance indicators, including current CPU load averages, detailed memory usage (total, used, free, buffers/cache), available disk space on all mounted filesystems, and the count of pending system updates. This holistic overview provides immediate context about the system's resource utilization and security posture.

This snapshot allows administrators to rapidly identify or rule out common causes of performance degradation or instability. For instance, a high CPU load might point to a runaway process, critically low memory could explain sluggishness due to swapping, and insufficient disk space can lead to application failures or even prevent the system from booting. Information on pending updates also highlights potential security vulnerabilities. This script acts as a first-response diagnostic, guiding subsequent troubleshooting steps by quickly indicating whether the issue is likely related to resource exhaustion, storage problems, or outdated software.

**How it works**

> • CPU Load: Uses uptime for load averages or mpstat / vmstat for more detailed CPU usage.
> •	Memory Usage: Parses output from free -m.
> •	Disk Space: Parses output from df -h.
> •	Pending Updates: * For Debian/Ubuntu: apt list --upgradable | wc -l (adjusting for header lines). * For RHEL/CentOS/Fedora (yum): yum check-update | grep -vc "^$" (approximate). * For RHEL/CentOS/Fedora (dnf): dnf check-update | wc -l (adjusting for header lines).
> •	Outputs everything as a formatted list or key-value pairs.


**How it works**

> •	CPU Load: Uses uptime for load averages or mpstat / vmstat for more detailed CPU usage.
> •	Memory Usage: Parses output from free -m.
> •	Disk Space: Parses output from df -h.
> •	Pending Updates: * For Debian/Ubuntu: apt list --upgradable | wc -l (adjusting for header lines). * For RHEL/CentOS/Fedora (yum): yum check-update | grep -vc "^$" (approximate). * For RHEL/CentOS/Fedora (dnf): dnf check-update | wc -l (adjusting for header lines).
> •	Outputs everything as a formatted list or key-value pairs.

**Usage Example**

```bash
Insert example here
```

*(Run it again after fixes and `Compare-Object` the two logs to quantify improvement.)*

---

### Code

```bash
Insert code here
```
---

## Detect
### 5️⃣ Detect‑BruteForceLogons

A sudden or sustained increase in failed login attempts may indicate a potential brute-force attack targeting user accounts or system services, such as SSH. This script is designed to proactively analyze authentication logs (including /var/log/auth.log, /var/log/secure, or journalctl output for sshd and other login services) for instances of failed login attempts over a user-defined duration. The script aggregates these failures by source IP address and targeted user account.

This tool flags instances that exceed a predefined threshold by enabling administrators to identify and respond to active attacks quickly. The aggregated data reveals patterns, such as a single IP address attempting access to multiple accounts or a specific account targeted by various IP addresses. Such insights inform defensive measures, including blocking malicious IP addresses, temporary account locks, or implementing stricter password policies and account lockout procedures. Automating this detection serves as an early warning system that mitigates the risk of unauthorized access before a compromise occurs.

**How it works**

> •	Accepts hours_back and threshold parameters.
> •	For journalctl: journalctl _SYSTEMD_UNIT=sshd.service --since "X hours ago" | grep "Failed password"
> •	For log files: grep "Failed password" /var/log/auth.log (and similar for other services like su, sudo).
> •	Uses awk, sed, grep to extract source IP addresses and usernames from log entries.
> •	Uses sort | uniq -c to count attempts per IP/username combination.
> •	Filters for combinations where count ≥ Threshold.
> •	Outputs a report, possibly to a CSV or formatted text.

**Usage Example**

```bash
Insert example here
```

### Code

```bash
Insert code here
```

---

## Listening-Ports
### 6️⃣ Get‑ListeningPorts

Understanding which services actively listen for network connections is essential for maintaining system security and facilitating effective network troubleshooting. This utility meticulously catalogs all TCP and UDP ports currently in a LISTEN state on the system. Additionally, it correlates each listening port with its respective owning process, Process ID (PID), and, where applicable, the complete executable path of the program, thereby providing a comprehensive overview of network-facing services.

From a security perspective, this information is critical for identifying unauthorized or unexpected services that may be open to incoming connections. Such services may indicate the presence of backdoors, malicious activity, or misconfigurations that create unnecessary vulnerabilities. In terms of troubleshooting, this utility enables administrators to confirm that legitimate services are operating as intended, listen to the appropriate IP addresses and ports, and facilitate the swift identification and resolution of port conflicts between various applications. This ensures reliable network service delivery.

**How it works**

> •	Uses ss -tulnp or netstat -tulnp. The -l flag shows listening sockets, -t for TCP, -u for UDP, -n for numeric ports/hosts, -p to show PID/program name.
> • Parses the output to present: Protocol, Local Address:Port, PID/Program Name.
> •	The program name might include the path, or further lookup in /proc/[PID]/exe could be done.
> •	Outputs a sortable table.

**Usage Example**

```bash
Insert example here
```

### Code

```bash
Insert code here
```

---

## Audit
### 7️⃣ Audit‑LocalAdminMembers

Uncontrolled or excessive privileged access, including users with root or sudo capabilities, represents a significant security risk to any Linux system. This script is designed to uphold stringent control over administrative privileges by systematically enumerating all local users with administrative rights. This includes users with a User ID (UID) of 0 (the traditional root user) and users who are members of groups typically granted sudo privileges (such as 'sudo' or 'wheel' groups).

A notable feature of this script is its capability to compare the identified list of administrative users against a predetermined list of authorized administrators. This comparison promptly highlights discrepancies, such as unauthorized new administrative accounts or legitimate accounts that should have had their privileges revoked. This process is instrumental in enforcing the principle of least privilege. Regular audits utilizing this script assist in identifying potential insider threats, compromised accounts with escalated privileges, or administrative oversights, ensuring that the system's administrative user base remains secure and complies with organizational policies. licies
a
It parses the output to present the following information: Protocol, Local Address: Port, and PID/Program Name. The program name may include the path, or further lookup in `/proc/[PID]/exe` may be performed.

The output is presented in a sortable table.

### Usage Example
```
./get_listening_ports.sh | grep nginx
./get_listening_ports.sh --protocol tcp
```


**How it works**

> •	Checks /etc/passwd for users with UID 0: awk -F: '($3 == 0) { print $1 }' /etc/passwd.
> •	Checks members of privileged groups (e.g., sudo, wheel) by parsing /etc/group: grep -E '^sudo:|^wheel:' /etc/group | awk -F: '{print $4}' | tr ',' '\n'.
> •	Compares these lists against a predefined "safe list" of expected admin/sudo users.
> •	Flags any unexpected privileged accounts.

**Usage Example**

```bash
Insert example here
```

### Code

```bash
Insert code here
```

---

## Scan
### 8️⃣ Invoke-AntivirusSca

Conducting an on-demand antivirus or anti-malware scan on Linux systems is essential to incident response procedures and routine security assessments. This utility allows users to initiate a comprehensive scan utilizing a standard Linux-compatible antivirus engine, such as ClamAV, which can target specified paths or the entire filesystem. The primary objective is identifying various threats, including viruses, trojans, malware, and potentially unwanted programs (PUPs) that may have compromised the system.

Upon conclusion of the scan, the script generates a summary of the findings in a clear and actionable format. This summary typically includes the number of files scanned, the number of infections detected, and detailed information concerning any malicious files identified, including their respective locations and the nature of the threats. Such comprehensive reporting enables administrators to swiftly evaluate the situation and undertake necessary remediation actions, such as quarantining or eliminating infected files. This tool proves particularly valuable for scanning high-risk areas, such as web server document roots, email spools, or user upload directories, where malicious content is frequently introduced.

**How it works**

> •	Checks if clamscan (or another specified AV tool) is installed and in PATH.
> •	Accepts parameters for scan type (e.g., --path /home or --full which might scan /).
> •	Executes clamscan -r [path] (recursive scan).
> •	Captures the output, specifically looking for infected files summaries.
> •	Prints a summary of threats found or a "no threats detected" message.


**Usage Example**

```bash
Insert example here
```

### Code

```bash
Insert code here
```

---
 
## Network
## 9️⃣ Test‑NetworkConnectivity

When network-related issues occur, it is imperative to quickly ascertain whether the problem resides locally on the machine, within the local network segment (for example, the gateway or local DNS server), or with an external host or service. This script offers a streamlined approach to testing network reachability to one or more specified target hosts or IP addresses by utilizing foundational network diagnostic tools such as `ping` and either `traceroute` or `mtr` (My Traceroute).

The process begins with the `ping` command to evaluate basic reachability, latency, and packet loss to the specified target. If additional diagnosis is warranted, the script employs `traceroute` or `mtr` to delineate the network path hop-by-hop from the source machine to the destination. This path analysis is invaluable for identifying the specific locations of network failures or significant latency spikes along the route, thereby assisting administrators in differentiating between issues relating to the local system's network configuration, intermediary network devices, or remote endpoints. Such a thorough approach significantly accelerates the troubleshooting process.

**How it works**

> •	Accepts a list of target hostnames or IP addresses.
> •	For each target: * Uses ping -c 4 <target> to check basic reachability and average RTT. * If ping fails or for more detail, uses traceroute -n <target> or mtr -n -r -c 1 <target> to show hops.
> •	Outputs a summary table: Target, Reachable (Yes/No), Avg RTT (ms), Hops (if traceroute run).


**Usage Example**

```bash
Insert example here
```

### Code

```bash
Insert code here
```
---

## FirewallRules
### 🔟 Export‑WindowsFirewallRules

The configuration of a firewall is essential for the security of Linux systems, as its rules can change over time due to updates, software installations, or unintentional edits. This script provides a reliable means to export live firewall rules—from iptables, nftables, or other popular Linux firewalls—into a human-readable file. 

This exported file serves several key purposes: it acts as a backup for quick restoration, aids in auditing by offering a clear snapshot of the configuration, and facilitates change tracking by documenting modifications over time. This comprehensive approach enhances security and ensures compliance with organizational policies.

**How it works**

>•	Detects which firewall system is likely in use (iptables or nftables).
> •	For iptables: Uses iptables-save > outputfile.txt.
> •	For nftables: Uses nft list ruleset > outputfile.txt. (For JSON: nft list ruleset -j > outputfile.json if supported and desired).
> •	Saves the output to a specified file.
> •	Provides a message indicating the export location.

**Usage Example**

```bash
Insert example here
```

### Code

```bash
Insert code here
```

---

## Conclusion

Conclusion

The Bash-Linux-Troubleshoot Toolkit represents a practical and purpose-driven resource for professionals and learners who prioritize speed, precision, and simplicity in Linux administration. Each script is meticulously designed to aid users in understanding and promptly addressing underlying issues using reliable tools available on most Linux systems. This toolkit benefits a range of users, from junior engineers managing their inaugural server to security analysts addressing threats and IT managers seeking to empower their teams while streamlining the troubleshooting workflow.

Beyond its functional merits, this compilation is an educational tool and a subject for discussion. Recruiters can assess real-world scripting skills, mentors can leverage the scripts to elucidate best practices, and contributors can evolve the toolkit to adapt to changing infrastructural needs. The toolkit remains versatile and extensible by maintaining a focus on clear, concise, and actionable scripting.

Thank you for your engagement with the Bash-Linux-Troubleshoot Toolkit. We aspire that it becomes an essential component of your operational playbook and an inspiration for developing automation-first solutions. We welcome your feedback and collaboration to enhance this resource for the broader open-source and IT community.

⭐ The future repository if you find this concept useful! As scripts are developed, issues with bugs or new features are raised. Happy scripting — and automate all the things! 


🔍 — Happy hunting and automate *all* the things! 
